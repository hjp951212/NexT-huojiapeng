<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>嘭嘭嘭鹏</title>
  
  <subtitle>Stay Hungry, Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hdpx.netlify.com/"/>
  <updated>2019-03-20T03:01:16.456Z</updated>
  <id>https://hdpx.netlify.com/</id>
  
  <author>
    <name>嘭嘭嘭鹏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跨域及解决方案</title>
    <link href="https://hdpx.netlify.com/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://hdpx.netlify.com/跨域及解决方案/</id>
    <published>2019-03-20T01:29:14.000Z</published>
    <updated>2019-03-20T03:01:16.456Z</updated>
    
    <content type="html"><![CDATA[<p>跨域在接口调用的时候经常会出现，它是基于什么原因产生的呢？</p><h4 id="说到跨域就必须提到同源策略。什么是同源策略呢？"><a href="#说到跨域就必须提到同源策略。什么是同源策略呢？" class="headerlink" title="说到跨域就必须提到同源策略。什么是同源策略呢？"></a>说到跨域就必须提到同源策略。什么是同源策略呢？</h4><p>同源策略是由 Netscape 公司提出的一个著名的安全策略，所有支持 JavaScript 的浏览器都会使用这个策略。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指，域名，协议，端口相同。当页面在执行一个脚本时会检查访问的资源是否同源，如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。</p><h4 id="同源策略一般又分为以下两种："><a href="#同源策略一般又分为以下两种：" class="headerlink" title="同源策略一般又分为以下两种："></a>同源策略一般又分为以下两种：</h4><p>DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。</p><h4 id="什么是跨域呢？"><a href="#什么是跨域呢？" class="headerlink" title="什么是跨域呢？"></a>什么是跨域呢？</h4><p>跨域，指的是从一个域名去请求另外一个域名的资源。即跨域名请求！跨域时，浏览器不能执行其他域名网站的脚本，是由浏览器的同源策略造成的，是浏览器施加的安全限制。<br>跨域的严格一点来说就是只要协议，域名，端口有任何一个的不同，就被当作是跨域。<br><img src="https://upload-images.jianshu.io/upload_images/3279071-086a93aa9d710f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跨域报错"></p><h4 id="为什么要跨域？"><a href="#为什么要跨域？" class="headerlink" title="为什么要跨域？"></a>为什么要跨域？</h4><p>现实工作开发中经常会有跨域的情况，因为公司会有很多项目，也会有很多子域名，各个项目或者网站之间需要相互调用对方的资源，避免不了跨域请求。</p><h4 id="介绍几种跨域解决方案"><a href="#介绍几种跨域解决方案" class="headerlink" title="介绍几种跨域解决方案"></a>介绍几种跨域解决方案</h4><h6 id="1-通过jsonp跨域"><a href="#1-通过jsonp跨域" class="headerlink" title="1.通过jsonp跨域"></a>1.通过jsonp跨域</h6><ul><li>jsonp是什么呢？<br>jsonp 全称是JSON with Padding,是为了解决跨域请求资源而产生的解决方案,是一种依靠开发人员创造出的一种非官方跨域数据交互协议。</li><li>jsonp的产生<br>AJAX直接请求普通文件存在跨域无权限访问的问题,不管是静态页面也好，不过我们在调用js文件的时候又不受跨域影响,比如引入jquery框架的,或者是调用相片的时候，凡是拥有scr这个属性的标签都可以跨域例如script、img、iframe，如果想通过纯web端跨域访问数据只有一种可能,那就是把远程服务器上的数据装进js格式的文件里，而json又是一个轻量级的数据格式,还被js原生支持，为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback 参数给服务端，<br>(1).使用jquery的getJSON()方法，需要注意的是，url中要添加一个参数：callback=?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var id_number = $(&quot;#idNumber&quot;).val();</span><br><span class="line">var user_name = $(&quot;#staffName&quot;).val();</span><br><span class="line">var url = &quot;http://132.228.156.103:9188/DataSync/CheckResult?callback=?&amp;SeqNo=1&amp;ChannelID=1003&quot; +</span><br><span class="line">&quot;&amp;ID=&quot;+id_number+&quot;&amp;Name=&quot;+user_name;    </span><br><span class="line">$.getJSON(url,function(data)&#123;</span><br><span class="line">　　if(data.result == &quot;00&quot;)&#123;</span><br><span class="line">　　　　console.log(data.smsg);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>(2).jsonp形式的ajax请求:并且通过get请求的方式传入参数。<br>【<strong>注意:跨域请求是只能是get请求不能使用post请求</strong>】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var url = &quot;http://132.228.156.103:9188/DataSync/CheckResult?callback=?&amp;SeqNo=1&amp;ChannelID=1003&quot; +</span><br><span class="line">&quot;&amp;ID=&quot;+id_number+&quot;&amp;Name=&quot;+user_name;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">　　type:&apos;GET&apos;,</span><br><span class="line">　　url : url,</span><br><span class="line">　　jsonpCallback: &apos;jsonCallback&apos;,</span><br><span class="line">　　contentType: &quot;application/json&quot;,</span><br><span class="line">　　dataType:&quot;jsonp&quot;,</span><br><span class="line">　　success:function(json)&#123;</span><br><span class="line">　　　　alert(json);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li>jsonp 传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(默认为:callback)<br>jsonpCallback 自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名</li></ul><h6 id="2-document-domain-iframe跨域"><a href="#2-document-domain-iframe跨域" class="headerlink" title="2.document.domain + iframe跨域"></a>2.document.domain + iframe跨域</h6><p>此方案仅限主域相同，子域不同的跨域应用场景。<br>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。<br>a.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">            document.domain = &apos;study.cn&apos;;</span><br><span class="line">            function test() &#123;</span><br><span class="line">                alert(document.getElementById(&apos;a&apos;).contentWindow);</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;iframe id=&apos;a&apos; src=&apos;http://b.study.cn/b.html&apos; onload=&apos;test()&apos;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>b.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">document.domain = &apos;study.cn&apos;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    我是b.study.cn的body</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>我们就可以通过js访问到iframe中的各种属性和对象了</p><p>如果你想在<a href="http://a.study.cn/a.html页面中通过ajax直接请求页面http://b.study.cn/b.html，即使你设置了相同的document.domain也还是不行的" target="_blank" rel="noopener">http://a.study.cn/a.html页面中通过ajax直接请求页面http://b.study.cn/b.html，即使你设置了相同的document.domain也还是不行的</a>.</p><p>所以修改document.domain的方法只适用于不同子域的框架(父类与子类)间的交互。</p><p>如果想通过使用ajax的方法去与不同子域间的数据交互或者是js调用，只有两种方法,一种是使用jsonp的方法外，还有一种是使用iframe来做一个代理。</p><p>原理就是让这个 iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据 的，</p><p>然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发 送ajax请求，然后收到的数据我们也可以获得了。</p><h6 id="3-location-hash-iframe"><a href="#3-location-hash-iframe" class="headerlink" title="3.location.hash + iframe"></a>3.location.hash + iframe</h6><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。<br>a.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line"></span><br><span class="line">    // 向b.html传hash值</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        iframe.src = iframe.src + &apos;#user=admin&apos;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    </span><br><span class="line">    // 开放给同域c.html的回调方法</span><br><span class="line">    function onCallback(res) &#123;</span><br><span class="line">        alert(&apos;data from c.html ---&gt; &apos; + res);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>b.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line"></span><br><span class="line">    // 监听a.html传来的hash值，再传给c.html</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>c.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 监听b.html传来的hash值</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        // 再通过操作同域a.html的js回调，将结果传回</span><br><span class="line">        window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h6 id="4-window-name-iframe跨域"><a href="#4-window-name-iframe跨域" class="headerlink" title="4.window.name + iframe跨域"></a>4.window.name + iframe跨域</h6><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。<br>a.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var proxy = function(url, callback) &#123;</span><br><span class="line">    var state = 0;</span><br><span class="line">    var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line"></span><br><span class="line">    // 加载跨域页面</span><br><span class="line">    iframe.src = url;</span><br><span class="line"></span><br><span class="line">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        if (state === 1) &#123;</span><br><span class="line">            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line"></span><br><span class="line">        &#125; else if (state === 0) &#123;</span><br><span class="line">            // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">            iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;;</span><br><span class="line">            state = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br><span class="line">    function destoryFrame() &#123;</span><br><span class="line">        iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 请求跨域b页面数据</span><br><span class="line">proxy(&apos;http://www.domain2.com/b.html&apos;, function(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>proxy.html，中间代理页，与a.html同域，内容为空即可。</p><p>b.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &apos;This is domain2 data!&apos;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h6 id="5-postMessage跨域"><a href="#5-postMessage跨域" class="headerlink" title="5.postMessage跨域"></a>5.postMessage跨域</h6><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p><p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。<br>a.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        var data = &#123;</span><br><span class="line">            name: &apos;aym&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 向domain2传送跨域数据</span><br><span class="line">        iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 接受domain2返回数据</span><br><span class="line">    window.addEventListener(&apos;message&apos;, function(e) &#123;</span><br><span class="line">        alert(&apos;data from domain2 ---&gt; &apos; + e.data);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>b.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(&apos;message&apos;, function(e) &#123;</span><br><span class="line">        alert(&apos;data from domain1 ---&gt; &apos; + e.data);</span><br><span class="line"></span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line"></span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h6 id="6-跨域资源共享（CORS）"><a href="#6-跨域资源共享（CORS）" class="headerlink" title="6.跨域资源共享（CORS）"></a>6.跨域资源共享（CORS）</h6><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p><p>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p><h6 id="7-nginx代理跨域"><a href="#7-nginx代理跨域" class="headerlink" title="7.nginx代理跨域"></a>7.nginx代理跨域</h6><h6 id="8-nodejs中间件代理跨域"><a href="#8-nodejs中间件代理跨域" class="headerlink" title="8.nodejs中间件代理跨域"></a>8.nodejs中间件代理跨域</h6><h6 id="9-WebSocket协议跨域"><a href="#9-WebSocket协议跨域" class="headerlink" title="9.WebSocket协议跨域"></a>9.WebSocket协议跨域</h6><p>参考文章：<a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011145364</a></p><p>————<em>愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跨域在接口调用的时候经常会出现，它是基于什么原因产生的呢？&lt;/p&gt;
&lt;h4 id=&quot;说到跨域就必须提到同源策略。什么是同源策略呢？&quot;&gt;&lt;a href=&quot;#说到跨域就必须提到同源策略。什么是同源策略呢？&quot; class=&quot;headerlink&quot; title=&quot;说到跨域就必须提到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js中事件是如何传播的？</title>
    <link href="https://hdpx.netlify.com/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD/"/>
    <id>https://hdpx.netlify.com/事件传播/</id>
    <published>2019-03-18T02:46:54.000Z</published>
    <updated>2019-03-18T02:47:22.230Z</updated>
    
    <content type="html"><![CDATA[<h4 id="小历史："><a href="#小历史：" class="headerlink" title="小历史："></a>小历史：</h4><p>事件传播的不同还要从早先的两家浏览器巨头说起，网景和IE为了能争夺市场，互相使用相反的技术，当网景使用事件捕获流的时候，IE则使用事件冒泡流。后来W3C为了能规范规定，直接折中，当事件发生时，先发生向下传播，当到底了以后再次使用事件冒泡，逐渐的冒泡到根节点。</p><h4 id="事件传播分三个阶段："><a href="#事件传播分三个阶段：" class="headerlink" title="事件传播分三个阶段："></a>事件传播分三个阶段：</h4><p>DOM事件流（event flow ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p><ul><li>在事件捕获阶段，事件从document对象沿着文档树向下传播给目标节点。如果目标的任何一个祖先注册了捕捉事件句柄，那么在事件传播的过程中，就会运行这些句柄（IE10及以下不支持捕获型事件）。</li><li>目标阶段发生在目标节点自身，这与0级事件模型提供的事件处理方法类似。</li><li>事件冒泡阶段，在这个阶段，事件将从目标元素向上传播回(像冒泡)Document对象的文档层次（IE8 及以下没有捕获阶段）。<br><img src="https://upload-images.jianshu.io/upload_images/3279071-98b11163d668f34e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件传播示意图"></li></ul><p>无论是事件捕获还是事件冒泡，它们都有一个共同的行为，就是事件传播，它就像一跟引线，只有通过引线才能将绑在引线上的鞭炮（事件监听器）引爆，试想一下，如果引线不导火了，那鞭炮就只有一响了！！！</p><p>dom标准事件流的触发的先后顺序为：先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。</p><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>与这两个事件密切相关的是addEventListener、attachEvent：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(event, listener, useCapture)</span><br></pre></td></tr></table></figure></p><p>参数定义：<br>event—（事件名称，如click，不带on）<br>listener—事件监听函数<br>useCapture—是否采用事件捕获进行事件捕捉，默认为false，即采用事件冒泡方式<br>addEventListener在 IE11、Chrome 、Firefox、Safari等浏览器都得到支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attachEvent(event,listener)</span><br></pre></td></tr></table></figure><p>参数定义：<br>event—（事件名称，如onclick，带on）<br>listener—事件监听函数。<br>attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经不在使用这个方法。</p><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><p>w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">evt.stopPropagation();</span><br><span class="line">evt.cancelBubble = true;</span><br></pre></td></tr></table></figure></p><p>在处理浏览器兼容问题时，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(evt.stopPropagation)&#123;</span><br><span class="line">evt.stopPropagation();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">evt.cancelBubble = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一种以阻止默认事件的方式去阻止冒泡行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return false</span><br></pre></td></tr></table></figure></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>event.stopPropagation();<br> 事件处理过程中，阻止了事件冒泡，但不会阻击默认行为</p></li><li><p>return false;<br> 事件处理过程中，阻止了事件冒泡，也阻止了默认行为</p></li><li><p>event.preventDefault();<br>它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为</p></li></ul><p>————<em>愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;小历史：&quot;&gt;&lt;a href=&quot;#小历史：&quot; class=&quot;headerlink&quot; title=&quot;小历史：&quot;&gt;&lt;/a&gt;小历史：&lt;/h4&gt;&lt;p&gt;事件传播的不同还要从早先的两家浏览器巨头说起，网景和IE为了能争夺市场，互相使用相反的技术，当网景使用事件捕获流的时候，IE
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RESTful API？What is it?</title>
    <link href="https://hdpx.netlify.com/RESTful-API/"/>
    <id>https://hdpx.netlify.com/RESTful-API/</id>
    <published>2019-03-18T02:46:00.000Z</published>
    <updated>2019-03-18T02:46:25.480Z</updated>
    
    <content type="html"><![CDATA[<p>REST全称是Representational State Transfer，中文意思是表述性状态转移。不管是英文还是中文解释，都难得其意！<br>那究竟指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)，标识的资源可能是服务器上的一个文件，不过，也可能是一个邮件地址、新闻消息、图书、人名、Internet主机或者任何其它内容。URI既可以看成是资源的地址，也可以看成是资源的名称，它包含URL和URN。</p><ul><li>URL = Universal Resource Locator 统一资源定位符<br>URL唯一地标识一个资源在Internet上的位置。不管用什么方法表示，只要能定位一个资源，就叫URL。</li><li>URN = Universal Resource Name 统一资源名称<br>URN它命名资源但不指定如何定位资源，比如：只告诉你一个人的姓名，不告诉你这个人在哪。<h4 id="一、URL-设计"><a href="#一、URL-设计" class="headerlink" title="一、URL 设计"></a>一、URL 设计</h4><blockquote><p>RESTful 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构。简单来说就是URL定位资源，用HTTP动词描述操作。<br>比如用GET来表示读取，POST表示新建，PUT表示更新，PATCH表示更新，但通常是部分更新，DELETE表示删除。</p></blockquote><h6 id="1-宾语必须是名词"><a href="#1-宾语必须是名词" class="headerlink" title="1.宾语必须是名词"></a>1.宾语必须是名词</h6>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /article</span><br></pre></td></tr></table></figure></li></ul><h6 id="2-复数-URL"><a href="#2-复数-URL" class="headerlink" title="2.复数 URL"></a>2.复数 URL</h6><p>没有统一的规定，但是常见的操作是当要读取一个集合要用复数形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /articles</span><br></pre></td></tr></table></figure></p><h6 id="3-避免多级-URL"><a href="#3-避免多级-URL" class="headerlink" title="3.避免多级 URL"></a>3.避免多级 URL</h6><p>当资源需要多级分类时，比较好的做法是，除了第一级，其他级别都用查询字符串表达。这种URL不仅利于扩展，语义也更加明确。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /articles?published=true</span><br></pre></td></tr></table></figure></p><h4 id="二、状态码"><a href="#二、状态码" class="headerlink" title="二、状态码"></a>二、状态码</h4><h6 id="状态码表示必须明确"><a href="#状态码表示必须明确" class="headerlink" title="状态码表示必须明确"></a>状态码表示必须明确</h6><ul><li><p>通常来说：1xx表示相关信息，2xx表示操作成功，3xx表示重定向，4xx表示客户端错误，5xx表示服务器错误。RESTful就要求将这五类按不同请求方式进行细分。</p></li><li><p>以GET为例</p><blockquote><p>200（OK）——表示已在响应中发出<br>204（无内容） —— 资源有空表示<br>301（Moved Permanently） —— 资源的URI已被更新<br>303（See Other） —— 其他（如，负载均衡）<br>304（not modified）—— 资源未更改（缓存）<br>400 （bad request）—— 指代坏请求（如，参数错误）<br>404 （not found）—— 资源不存在<br>406 （not acceptable）—— 服务端不支持所需表示<br>500 （internal server error）—— 通用错误响应<br>503 （Service Unavailable）—— 服务端当前无法处理请求</p></blockquote><h4 id="三、服务器回应"><a href="#三、服务器回应" class="headerlink" title="三、服务器回应"></a>三、服务器回应</h4><h6 id="1-不要返回纯本文"><a href="#1-不要返回纯本文" class="headerlink" title="1.不要返回纯本文"></a>1.不要返回纯本文</h6><p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。<br>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。</p><h6 id="2-发生错误时，不要返回-200-状态码"><a href="#2-发生错误时，不要返回-200-状态码" class="headerlink" title="2.发生错误时，不要返回 200 状态码"></a>2.发生错误时，不要返回 200 状态码</h6><p>状态码反映发生的错误，并将具体的错误信息放在数据体里面返回。在发生错误时也返回200状态码，这种做法是不恰当的。</p><h6 id="3-提供链接"><a href="#3-提供链接" class="headerlink" title="3.提供链接"></a>3.提供链接</h6><p>在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。</p><blockquote><p>HATEOAS(Hypermedia as the engine of application state)，超媒体即应用状态引擎。它是REST架构的主要约束。“hepermedia”表示任何包含指向图片、电影、文字等资源的链接，Web是超媒体的经典例子。HATEOAS背后的思想其实非常简单，就是响应中包含指向其它资源的链接。客户端可以利用这些链接和服务器交互。</p></blockquote></li></ul><p>超媒体是什么?<br>当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来。<br>要达到这个目的，就要求在表述格式里边加入链接来引导客户端。在《RESTful Web Services》一书中，作者把这种具有链接的特性成为连通性。<br>这一特性应用特别广泛，比如创建订单后通过链接引导客户端如何去付款。</p><p>————<em>愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;REST全称是Representational State Transfer，中文意思是表述性状态转移。不管是英文还是中文解释，都难得其意！&lt;br&gt;那究竟指的是什么的表述? 其实指的就是资源。任何事物，只要有被引用到的必要，它就是一个资源。要让一个资源可以被识别，需要有个唯
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的HTTP？不常见的大道理！</title>
    <link href="https://hdpx.netlify.com/HTTP/"/>
    <id>https://hdpx.netlify.com/HTTP/</id>
    <published>2019-03-18T02:45:05.000Z</published>
    <updated>2019-03-18T02:45:39.728Z</updated>
    
    <content type="html"><![CDATA[<h4 id="先来看看一次完整的HTTP请求流程"><a href="#先来看看一次完整的HTTP请求流程" class="headerlink" title="先来看看一次完整的HTTP请求流程"></a>先来看看一次完整的HTTP请求流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/3279071-915d08d268077d20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP请求和响应步骤"></p><h4 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h4><p>１.HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。<br>２.HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><h4 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h4><p>１. HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<br>２.Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。<br>３.Web服务器根据接收到的请求后，向客户端发送响应信息。<br>４.HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p><h4 id="HTTP消息结构"><a href="#HTTP消息结构" class="headerlink" title="HTTP消息结构"></a>HTTP消息结构</h4><p>1.HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。无状态是指Web浏览器和Web服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.</p><p>2.HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。<br><img src="https://upload-images.jianshu.io/upload_images/3279071-c46c0af79c9241f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="http请求结构"></p><h6 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h6><p>分为三个部分：请求方法、请求地址和协议版本。</p><ul><li>请求方法：HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</li><li>请求地址：由协议，主机，端口，路径组成</li><li>版本协议：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1<h6 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h6>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。<h6 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h6>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。<h6 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h6>可选部分，比如GET请求就没有请求数据。</li></ul><p>####服务器响应消息<br>HTTP响应也由四个部分组成，分别是：状态行、响应头部、空行和响应正文。</p><h6 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h6><p>由协议版本，状态码，状态码描述三部分组成。其中协议版本与请求报文一致，状态码描述是对状态码的简单描述。</p><ul><li>一些常见的状态码为：<br>200 - 服务器成功返回网页<br>302 - 跳转到响应头location属性指定地址<br>400 - 客户端请求语法有误，不能被服务器识别<br>403 - 服务器收到请求，但拒绝服务（认证失败）<br>404 - 请求的网页不存在<br>500 - 服务器内部错误<br>503 - 服务不可用<h6 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h6>与请求头部类似，为响应报文添加了一些附加信息。<h6 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h6>用于存放需要返回给客户端的数据信息。</li></ul><p>————<em>愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;先来看看一次完整的HTTP请求流程&quot;&gt;&lt;a href=&quot;#先来看看一次完整的HTTP请求流程&quot; class=&quot;headerlink&quot; title=&quot;先来看看一次完整的HTTP请求流程&quot;&gt;&lt;/a&gt;先来看看一次完整的HTTP请求流程&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈那些让人头疼的浏览器兼容问题</title>
    <link href="https://hdpx.netlify.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    <id>https://hdpx.netlify.com/浏览器兼容/</id>
    <published>2019-03-18T02:44:11.000Z</published>
    <updated>2019-03-18T02:45:15.042Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器兼容性问题，是因为不同浏览器的内核不同，导致各个浏览器对网页的解析存在一定的差异，对同一段代码有不同的解析，造成页面显示效果不统一的情况。在大多数情况下，我们的需求是，无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。所以浏览器的兼容性问题是前端开发人员经常会碰到和必须要解决的问题。做前端最怕什么？就是IE6！调个兼容能被搞得心力憔悴。前端最喜欢看到的就是各家浏览器大统一，告别浏览器兼容调试。</p><h4 id="常见的浏览器内核可以分四种：Trident、Gecko、Blink、Webkit"><a href="#常见的浏览器内核可以分四种：Trident、Gecko、Blink、Webkit" class="headerlink" title="常见的浏览器内核可以分四种：Trident、Gecko、Blink、Webkit"></a>常见的浏览器内核可以分四种：Trident、Gecko、Blink、Webkit</h4><table><thead><tr><th>浏览器</th><th>内核</th></tr></thead><tbody><tr><td>IE浏览器</td><td>Trident内核，也称为IE内核</td></tr><tr><td>Chrome浏览器</td><td>Blink内核</td></tr><tr><td>Firefox浏览器</td><td>Gecko内核，俗称Firefox内核</td></tr><tr><td>Safari浏览器</td><td>Webkit内核</td></tr><tr><td>Opera浏览器</td><td>最初是自己的Presto内核，后来从Webkit又到了Blink内核；</td></tr><tr><td>360浏览器</td><td>IE+Chrome双内核</td></tr><tr><td>猎豹浏览器</td><td>IE+Chrome双内核</td></tr><tr><td>百度浏览器</td><td>IE内核</td></tr><tr><td>QQ浏览器</td><td>Trident（兼容模式）+Webkit（高速模式）</td></tr></tbody></table><h4 id="以下列出一些常见的浏览器兼容问题："><a href="#以下列出一些常见的浏览器兼容问题：" class="headerlink" title="以下列出一些常见的浏览器兼容问题："></a>以下列出一些常见的浏览器兼容问题：</h4><h5 id="1-不同浏览器的标签默认的margin和padding不同"><a href="#1-不同浏览器的标签默认的margin和padding不同" class="headerlink" title="1.不同浏览器的标签默认的margin和padding不同"></a>1.不同浏览器的标签默认的margin和padding不同</h5><p>不同的标签，不加样式控制的情况下，各自的margin 和padding差异较大。</p><ul><li>解决方案：<br>可以使用Normalize.css来清除默认样式，也可以使用如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body,h1,h2,h3,ul,li,input,div,span,a,form …… &#123; margin:0; padding:0; &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度"><a href="#2-设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度" class="headerlink" title="2.设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度"></a>2.设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度</h5><ul><li>解决方案<br>给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。<h5 id="3-IE6双边距问题，在IE6中设置了float-同时又设置margin-就会出现边距问题"><a href="#3-IE6双边距问题，在IE6中设置了float-同时又设置margin-就会出现边距问题" class="headerlink" title="3.IE6双边距问题，在IE6中设置了float , 同时又设置margin , 就会出现边距问题"></a>3.IE6双边距问题，在IE6中设置了float , 同时又设置margin , 就会出现边距问题</h5></li><li>解决方案：<br>设置display:inline;<h5 id="4-图片默认有间距"><a href="#4-图片默认有间距" class="headerlink" title="4.图片默认有间距"></a>4.图片默认有间距</h5></li><li>解决方案：<br>使用float 为img 布局<h5 id="5-IE9一下浏览器不能使用opacity"><a href="#5-IE9一下浏览器不能使用opacity" class="headerlink" title="5.IE9一下浏览器不能使用opacity"></a>5.IE9一下浏览器不能使用opacity</h5></li><li>解决方案：<br>opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);<h5 id="6-cursor-hand-显示手型在safari-上不支持"><a href="#6-cursor-hand-显示手型在safari-上不支持" class="headerlink" title="6.cursor:hand 显示手型在safari 上不支持"></a>6.cursor:hand 显示手型在safari 上不支持</h5></li><li>解决方案：<br>统一使用 cursor:pointer<h5 id="7-边距重叠问题"><a href="#7-边距重叠问题" class="headerlink" title="7.边距重叠问题"></a>7.边距重叠问题</h5>当相邻两个元素都设置了margin 边距时，margin 将取最大值，舍弃最小值；</li><li>解决方案：<br>为了不让边重叠，可以给子元素增加一个父级元素，并设置父级元素为overflow:hidden；<h5 id="8-两个块级元素，父元素设置了overflow-auto；子元素设置了position-relative-且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；"><a href="#8-两个块级元素，父元素设置了overflow-auto；子元素设置了position-relative-且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；" class="headerlink" title="8.两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；"></a>8.两个块级元素，父元素设置了overflow:auto；子元素设置了position:relative ;且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；</h5></li><li>解决方案：<br>父级元素设置position:relative<h5 id="9-标签最低高度设置min-height不兼容"><a href="#9-标签最低高度设置min-height不兼容" class="headerlink" title="9.标签最低高度设置min-height不兼容"></a>9.标签最低高度设置min-height不兼容</h5>min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容</li><li>解决方案：<br>如果我们要设置一个标签的最小高度200px，需要进行的设置为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;min-height:200px; height:auto ![ImportAnt]; height:200px; overflow:visible;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在网站设计的时候，应该注意css样式兼容不同浏览器问题，特别是对完全使用DIV CSS设计的网，就应该更注意IE6 IE7 FF对CSS样式的兼。下面针对不同浏览器列出其专用写法：<br>浏览器     | 写法<br>——– | —–<br>通用  |  height: 100px;<br>IE6 专用  | _height: 100px;<br>IE6 专用   | <em>height: 100px;<br>IE7 专用  | </em>+height: 100px;<br>IE7、FF 共用  | height: 100px !important;</p><p>————<em>愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浏览器兼容性问题，是因为不同浏览器的内核不同，导致各个浏览器对网页的解析存在一定的差异，对同一段代码有不同的解析，造成页面显示效果不统一的情况。在大多数情况下，我们的需求是，无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。所以浏览器的兼容性问
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web页面性能优化以及SEO</title>
    <link href="https://hdpx.netlify.com/web%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8ASEO/"/>
    <id>https://hdpx.netlify.com/web页面性能优化以及SEO/</id>
    <published>2019-03-16T06:37:24.000Z</published>
    <updated>2019-03-16T06:37:54.899Z</updated>
    
    <content type="html"><![CDATA[<ul><li>web页面性能优化能够提高页面加载速度，提升用户体验度，基于三秒法则，每个网站都极力优化页面性能。</li><li>SEO(Search Engine Optimization)是一种提高网站流量的优化手段。</li></ul><h4 id="一、web页面性能优化"><a href="#一、web页面性能优化" class="headerlink" title="一、web页面性能优化"></a>一、web页面性能优化</h4><h5 id="1-html语义化"><a href="#1-html语义化" class="headerlink" title="1.html语义化"></a>1.html语义化</h5><p>语义化是让标签做自己该做的事，便于其他开发者阅读以及使代码规范，优雅整洁。比如div,span,h,ul,ol,dl,p等等这类的标签的使用。应该非常合理，还有就是注意h标签的断层，及h1标签的使用，这些都是非常重要的。</p><h5 id="2-减少http请求"><a href="#2-减少http请求" class="headerlink" title="2.减少http请求"></a>2.减少http请求</h5><ul><li>从设计实现层面简化页面，保持页面简洁、减少资源的使用时最直接的。</li><li>合理设置缓存</li><li>资源合并与压缩，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。</li><li>css精灵，合并 CSS图片，减少请求次数。<h5 id="3-css，js文件数量及大小的优化"><a href="#3-css，js文件数量及大小的优化" class="headerlink" title="3.css，js文件数量及大小的优化"></a>3.css，js文件数量及大小的优化</h5></li><li>减少重复代码，对代码进行模块化开发。</li><li>压缩css，js文件，利用gulp、grunt等压缩工具<h5 id="4-减少cookie传输"><a href="#4-减少cookie传输" class="headerlink" title="4.减少cookie传输"></a>4.减少cookie传输</h5></li><li>cookie包含在每次请求和响应中，太大的cookie会严重影响数据传输，因此哪些数据需要写入cookie需要慎重考虑，尽量减少cookie中传输的数据量。</li><li>对于某些静态资源的访问，如CSS、script等，发送cookie没有意义，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送cookie，减少cookie传输次数。　　<h5 id="5-将外部脚本置底"><a href="#5-将外部脚本置底" class="headerlink" title="5.将外部脚本置底"></a>5.将外部脚本置底</h5>将脚本内容在页面信息内容加载后再加载，外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。解决这一问题最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。<h5 id="6-将-CSS放在-HEAD中"><a href="#6-将-CSS放在-HEAD中" class="headerlink" title="6.将 CSS放在 HEAD中"></a>6.将 CSS放在 HEAD中</h5>如果将 CSS放在其他地方比如body中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面刚开始是无样式的状态，用户体验比较差。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。<h5 id="7-DOM"><a href="#7-DOM" class="headerlink" title="7.DOM"></a>7.DOM</h5>DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。<h5 id="8-避免使用-eval和-Function"><a href="#8-避免使用-eval和-Function" class="headerlink" title="8.避免使用 eval和 Function"></a>8.避免使用 eval和 Function</h5>　　每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 ( 通常比简单的函数调用慢 100倍以上)。<h5 id="9-减少作用域链查找"><a href="#9-减少作用域链查找" class="headerlink" title="9. 减少作用域链查找"></a>9. 减少作用域链查找</h5>尽量把变量设为局部变量，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。</li></ul><h4 id="二、SEO"><a href="#二、SEO" class="headerlink" title="二、SEO"></a>二、SEO</h4><ul><li>SEO是一种免费的提升网络权重的手段。与之对应的是SEM，即一种付费的营销手段，比如百度推广。</li><li>SEO排名机制，一靠搜索引擎蜘蛛（按分类抓取），二靠权重。</li><li>SEO优化最重要的三要素：标题，关键字，描述<h5 id="1-外链（友情链接）"><a href="#1-外链（友情链接）" class="headerlink" title="1.外链（友情链接）"></a>1.外链（友情链接）</h5>外链是指网站与网站之间的链接向导，提升权重的方式之一。利用互联网是链接与链接实现的一条网络这一特点，<br>链接权重高的大网站，可以让搜索引擎在爬取大网站的时候，顺着连接爬取到你的网站。<br>交换友情链接注意事项：<br>  (1).和内容相近的网站交换<br>  (2).链接交换形式多样（单向链接，双项链接，单向直链….）<br>  (3).灌水式外链<h5 id="2-内链（也称之为站内链接）"><a href="#2-内链（也称之为站内链接）" class="headerlink" title="2.内链（也称之为站内链接）"></a>2.内链（也称之为站内链接）</h5>在同一网站域名下的内容页面之间的互相链接（自己网站的内容链接到自己网站的内部页面）<h5 id="3-内容质量"><a href="#3-内容质量" class="headerlink" title="3.内容质量"></a>3.内容质量</h5>(1).更新，要不断更新你的网站内容。<br>(2).质量，网站内容要高质量。<br>(3).原创，坚持原创内容。<br>(4).关键词密度（2%~8%），一片文章中的关键字占比。<h5 id="4-话术设置（简短，内容丰富）"><a href="#4-话术设置（简短，内容丰富）" class="headerlink" title="4.话术设置（简短，内容丰富）"></a>4.话术设置（简短，内容丰富）</h5>选择比较有吸引力的标题。<h5 id="5-关键词的挖掘"><a href="#5-关键词的挖掘" class="headerlink" title="5.关键词的挖掘"></a>5.关键词的挖掘</h5>(1).头脑风暴<br>(2).利用搜索引擎相关搜索（百度指数）<br>(3).工具<br>(4).长尾关键词<h5 id="6-域名选择"><a href="#6-域名选择" class="headerlink" title="6.域名选择"></a>6.域名选择</h5>(1).后缀选择（.com  .net  .org）<br>(2).短域名<br>(3).域名语义<br>(4).域名的使用历史查询（查询网站不要有黑历史）<h5 id="7-服务器的选择"><a href="#7-服务器的选择" class="headerlink" title="7.服务器的选择"></a>7.服务器的选择</h5>(1).响应速度快（3s定律）<br>(2).稳定<h5 id="8-代码优化"><a href="#8-代码优化" class="headerlink" title="8.代码优化"></a>8.代码优化</h5>1.代码去冗余化（减少冗余，精简，模块化）<br>2.自动化工具（grunt，gulp，webPack，tinyPNG(压缩图片)…..）<br>3.标签语义化（p,h,a…）<h5 id="9-HTTP状态码-合理利用状态码去优化网页"><a href="#9-HTTP状态码-合理利用状态码去优化网页" class="headerlink" title="9.HTTP状态码(合理利用状态码去优化网页)"></a>9.HTTP状态码(合理利用状态码去优化网页)</h5>200（2开头表示网页响应成功）<br>300（302，304重定向）<br>404（网页不存在，可在404页面做公益活动或广告）<br>500（5，6开头表示服务器端错误）<h5 id="10-站群推广"><a href="#10-站群推广" class="headerlink" title="10.站群推广"></a>10.站群推广</h5>通过群体的方式去推广网站，提高网站流量。比如前进的淘宝客，通过发佣推广的方式为淘宝网站带来了一大批优质流量。<h5 id="其他手段"><a href="#其他手段" class="headerlink" title="其他手段"></a>其他手段</h5></li><li>提升客户体验，比如网页界面要简洁易用，网页界面要美观。</li><li>内容多样，可通过添加视频和更新一些新奇的内容。</li><li>代码属性优化。</li><li>相关搜索引擎产品协助，利用百度文库中放网站链接，或者更新一些高质量的内容，以便让百度新闻抓取到。</li></ul><p>————<em>愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;web页面性能优化能够提高页面加载速度，提升用户体验度，基于三秒法则，每个网站都极力优化页面性能。&lt;/li&gt;
&lt;li&gt;SEO(Search Engine Optimization)是一种提高网站流量的优化手段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;一、web页
      
    
    </summary>
    
    
  </entry>
  
</feed>
